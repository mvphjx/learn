		AOP(Aspect Oriented Programing)，即面向切面编程
它主要用于日志记录、性能统计、安全控制、事务处理、异常处理等方面。
它的主要意图就要将日志记录，性能统计，安全控制、事务处理、异常处理等等代码从业务逻辑代码中清楚地划分出来。
通过对这些行为的分离，我们希望可以将它们独立地配置到业务逻辑方法中，而要改变这些行为的时候也不需要影响到业务逻辑方法代码。


		代理模式与代理机制
代理模式是常用的Java设计模式。
代理类主要负责为委托类预处理消息、过滤信息、把消息转发给委托类，以及事后处理信息等。
深入地理解Java的反射和动态代理机制，同时对Spring中盛行的IOC和AOP的后台实现原理有了更加清晰的理解
代理机制：
1.通过实现InvocationHandler接口来自定义自己的InvocationHandler;
2.通过Proxy.getProxyClass获得动态代理类
3.通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)
4.通过构造函数获得代理对象并将自定义的InvocationHandler实例对象传为参数传入
5.通过代理对象调用目标方法（invoke）

		动态代理与静态代理
相比于静态代理，动态代理避免了开发人员编写各个繁锁的静态代理类，只需简单地指定一组接口及目标类对象就能动态的获得代理对象。


		CGLIB动态代理和JDK动态代理
AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。
两种方法同时存在，各有优劣。
jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。
总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。
还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。
如果没有上述前提，jdk动态代理不能应用。
由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。

